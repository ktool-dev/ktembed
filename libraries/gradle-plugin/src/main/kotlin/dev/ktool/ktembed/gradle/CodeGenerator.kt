package dev.ktool.ktembed.gradle

import java.io.File

/**
 * Generates Kotlin code for embedded resources.
 */
internal class CodeGenerator(
    private val packageName: String,
    private val chunkSize: Int,
    private val shardSize: Int,
    private val generateInMemory: Boolean,
    private val generateDiskCached: Boolean
) {
    
    /**
     * Generates Kotlin source files for the given resources.
     */
    fun generate(resources: List<ResourceFile>, outputDir: File) {
        if (resources.isEmpty()) {
            println("No resources to embed")
            return
        }
        
        outputDir.deleteRecursively()
        outputDir.mkdirs()
        
        if (shardSize > 0 && resources.size > shardSize) {
            // Generate sharded files
            generateSharded(resources, outputDir)
        } else {
            // Generate single file
            generateSingleFile(resources, outputDir, "KtEmbedResources")
        }
    }
    
    private fun generateSharded(resources: List<ResourceFile>, outputDir: File) {
        val shards = resources.chunked(shardSize)
        
        // Generate each shard
        shards.forEachIndexed { index, shard ->
            val shardName = "KtEmbedResources${index + 1}"
            generateSingleFile(shard, outputDir, shardName)
        }
        
        // Generate index file that aggregates all shards
        generateIndexFile(shards.size, outputDir)
    }
    
    private fun generateSingleFile(resources: List<ResourceFile>, outputDir: File, objectName: String) {
        val packageDir = outputDir.resolve(packageName.replace('.', '/'))
        packageDir.mkdirs()
        
        val file = packageDir.resolve("$objectName.kt")
        
        file.bufferedWriter().use { writer ->
            writer.appendLine("@file:Suppress(\"MaxLineLength\", \"LongLine\")")
            writer.appendLine()
            writer.appendLine("package $packageName")
            writer.appendLine()
            writer.appendLine("import dev.ktool.ktembed.*")
            writer.appendLine()
            writer.appendLine("/**")
            writer.appendLine(" * Embedded resources generated by KtEmbed")
            writer.appendLine(" * Generated from ${resources.size} resource(s)")
            writer.appendLine(" */")
            writer.appendLine("object $objectName {")
            writer.appendLine()
            
            resources.forEach { resource ->
                generateResourceCode(writer, resource)
            }
            
            writer.appendLine("}")
        }
        
        println("Generated $file with ${resources.size} resources")
    }
    
    private fun generateResourceCode(writer: java.io.BufferedWriter, resource: ResourceFile) {
        val propertyName = sanitizePropertyName(resource.path)
        val hash = ContentHasher.hash(resource.bytes)
        val chunks = Base64Encoder.encodeToChunks(resource.bytes, chunkSize)
        
        // Generate private chunks list
        writer.appendLine("    private val ${propertyName}_chunks = listOf(")
        chunks.forEach { chunk ->
            writer.appendLine("        \"${escapeString(chunk)}\",")
        }
        writer.appendLine("    )")
        writer.appendLine()
        
        // Determine which mode to use
        val mode = when {
            generateInMemory && !generateDiskCached -> "InMemory"
            !generateInMemory && generateDiskCached -> "DiskCached"
            else -> "InMemory" // Default to InMemory if both or neither
        }
        
        // Generate public property
        writer.appendLine("    /**")
        writer.appendLine("     * Resource: ${resource.path}")
        writer.appendLine("     * Size: ${resource.size} bytes")
        writer.appendLine("     * Mode: $mode")
        writer.appendLine("     */")
        
        val className = if (mode == "InMemory") "InMemoryResource" else "DiskCachedResource"
        writer.appendLine("    val $propertyName: EmbeddedResource = $className(")
        writer.appendLine("        path = \"${escapeString(resource.path)}\",")
        writer.appendLine("        contentHash = \"$hash\",")
        writer.appendLine("        base64Chunks = ${propertyName}_chunks")
        writer.appendLine("    )")
        writer.appendLine()
    }
    
    private fun generateIndexFile(shardCount: Int, outputDir: File) {
        val packageDir = outputDir.resolve(packageName.replace('.', '/'))
        val file = packageDir.resolve("KtEmbedResources.kt")
        
        file.bufferedWriter().use { writer ->
            writer.appendLine("package $packageName")
            writer.appendLine()
            writer.appendLine("/**")
            writer.appendLine(" * Index of all embedded resources across $shardCount shards")
            writer.appendLine(" */")
            writer.appendLine("object KtEmbedResources {")
            for (i in 1..shardCount) {
                writer.appendLine("    val shard$i = KtEmbedResources$i")
            }
            writer.appendLine("}")
        }
    }
    
    private fun sanitizePropertyName(path: String): String {
        // Replace non-alphanumeric characters with underscores
        val sanitized = path.replace(Regex("[^a-zA-Z0-9]"), "_")
        
        // Ensure it doesn't start with a digit
        return if (sanitized.firstOrNull()?.isDigit() == true) {
            "res_$sanitized"
        } else {
            sanitized
        }
    }
    
    private fun escapeString(str: String): String {
        return str.replace("\\", "\\\\")
            .replace("\"", "\\\"")
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace("\t", "\\t")
    }
}
